###############################################################################
# Telegraf Configuration - Latency Hunter
# 
# Collecteur gNMI pour streaming telemetry depuis Arista cEOS
# Résolution: 1 seconde (vs SNMP polling à 5+ minutes)
###############################################################################

[global_tags]
  project = "latency-hunter"
  environment = "lab"

[agent]
  interval = "1s"                    # Collecte toutes les 1 seconde (!!!)
  round_interval = true
  metric_batch_size = 1000
  metric_buffer_limit = 10000
  collection_jitter = "0s"           # Pas de jitter pour précision maximale
  flush_interval = "1s"
  flush_jitter = "0s"
  precision = "1ms"                  # Précision milliseconde
  hostname = "telegraf-collector"
  omit_hostname = false

###############################################################################
# OUTPUT - InfluxDB 2.x
###############################################################################

[[outputs.influxdb_v2]]
  urls = ["http://influxdb:8086"]
  token = "${INFLUX_TOKEN}"
  organization = "${INFLUX_ORG}"
  bucket = "${INFLUX_BUCKET}"
  timeout = "5s"
  
  # Options de performance
  content_encoding = "gzip"
  
  # Debug (décommenter si besoin)
  # [outputs.influxdb_v2.tagpass]
  #   debug = ["true"]

###############################################################################
# INPUT - gNMI (gRPC Network Management Interface)
###############################################################################

[[inputs.gnmi]]
  ## Adresse du switch (dans le réseau Docker bridge de Containerlab)
  addresses = ["172.20.20.10:6030"]
  
  ## Authentification
  username = "admin"
  password = "admin"
  
  ## Désactive TLS pour le lab (À ACTIVER EN PRODUCTION!)
  enable_tls = false
  insecure_skip_verify = true
  
  ## Encoding : JSON pour compatibilité maximale
  encoding = "json"
  
  ## Mode de collecte
  ## "subscribe" = streaming mode (push du switch vers Telegraf)
  ## "poll" = polling classique (plus lent)
  redial = "10s"
  
  ###########################################################################
  # SUBSCRIPTIONS - Définition des métriques à collecter
  ###########################################################################
  
  ## Subscription 1: Statistiques d'interface (LE CŒUR DU PROJET)
  ## Path OpenConfig pour les compteurs d'interface
  [[inputs.gnmi.subscription]]
    name = "interface_counters"
    origin = "openconfig"
    path = "/interfaces/interface/state/counters"
    subscription_mode = "sample"
    sample_interval = "1s"           # Collecte toutes les 1 seconde !!
  
  ## Subscription 2: Utilisation de la bande passante
  [[inputs.gnmi.subscription]]
    name = "interface_bandwidth"
    origin = "openconfig"
    path = "/interfaces/interface/state"
    subscription_mode = "sample"
    sample_interval = "1s"
  
  ## Subscription 3: État opérationnel des interfaces
  [[inputs.gnmi.subscription]]
    name = "interface_status"
    origin = "openconfig"
    path = "/interfaces/interface/state/oper-status"
    subscription_mode = "on_change"   # Notification instantanée si changement

  ## Subscription 4: Queue Depth (profondeur de file - CRITIQUE pour micro-bursts)
  ## Note: Le path exact peut varier selon la version d'Arista EOS
  [[inputs.gnmi.subscription]]
    name = "qos_queue_depth"
    origin = "openconfig"
    path = "/qos/interfaces/interface/output/queues/queue/state"
    subscription_mode = "sample"
    sample_interval = "1s"

###############################################################################
# INPUT - Exec (Optionnel: Ping pour latency baseline)
###############################################################################

[[inputs.exec]]
  commands = [
    "sh -c 'ping -c 1 -W 1 172.20.20.21 | grep time= | sed \"s/.*time=//\" | sed \"s/ ms//\"'"
  ]
  timeout = "2s"
  interval = "1s"
  name_override = "ping_latency"
  data_format = "value"
  data_type = "float"
  [inputs.exec.tags]
    target = "traffic-gen-1"

###############################################################################
# PROCESSOR - Calcul du taux d'utilisation (Derivate)
###############################################################################

[[processors.derivative]]
  ## Calcule le taux de changement (delta/seconde) des octets
  namepass = ["interface_counters"]
  
  ## Champs à dériver
  [[processors.derivative.fields]]
    field = "in_octets"
    dest = "in_octets_per_sec"
  
  [[processors.derivative.fields]]
    field = "out_octets"
    dest = "out_octets_per_sec"

###############################################################################
# PROCESSOR - Calcul du pourcentage d'utilisation
###############################################################################

[[processors.starlark]]
  namepass = ["interface_counters"]
  source = '''
def apply(metric):
    # Calcul du % d'utilisation (supposant 1 Gbps = 125 MB/s)
    # Ajuster selon la vitesse de vos interfaces
    link_speed_bytes = 125000000  # 1 Gbps en octets/seconde
    
    if "out_octets_per_sec" in metric.fields:
        util = (metric.fields["out_octets_per_sec"] / link_speed_bytes) * 100
        metric.fields["utilization_percent"] = max(0, min(100, util))
    
    return metric
'''

###############################################################################
# OUTPUT - Console (Debug - décommenter si nécessaire)
###############################################################################

# [[outputs.file]]
#   files = ["stdout"]
#   data_format = "influx"

